<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MKS SQL Parser Tester</title>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- HTMX -->
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <!-- Marked.js -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Highlight.js -->
    <link rel="stylesheet" id="hljs-theme"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <link rel="stylesheet" href="style.css">
</head>

<body class="light-mode">
    <header>
        <div class="header-left">
            <h1><i class="fas fa-database"></i> MKS SQL Parser Tester</h1>
        </div>
        <div class="header-center">
            <select id="test-chooser" name="testId" onchange="loadTest(this.value)">
                <option value="">Select a Test Case...</option>
                <!-- Options populated by JS -->
            </select>
        </div>
        <div class="header-right">
            <button id="theme-toggle" onclick="toggleTheme()" title="Toggle Dark/Light Mode">
                <i class="fas fa-moon"></i>
            </button>
            <button id="doc-toggle" onclick="toggleDoc()" title="Show Reference Guide">
                <i class="fas fa-book"></i>
            </button>
        </div>
    </header>

    <main class="container">
        <div class="editor-pane">
            <div class="pane-header">
                <label><i class="fas fa-code"></i> SQL Text</label>
                <div class="pane-actions">
                    <input type="file" id="upload-sql" accept=".sql,.txt" style="display:none"
                        onchange="loadFile(this, 'sql-text')">
                    <button class="icon-btn" onclick="document.getElementById('upload-sql').click()"
                        title="Upload File">
                        <i class="fas fa-upload"></i>
                    </button>
                    <button class="icon-btn" onclick="copyToClipboard('sql-text')" title="Copy to Clipboard">
                        <i class="fas fa-copy"></i>
                    </button>
                </div>
            </div>
            <textarea id="sql-text" name="sql" spellcheck="false"
                placeholder="Enter SQL here or drag & drop a file..."></textarea>
        </div>

        <div class="editor-pane">
            <div class="pane-header">
                <label><i class="fas fa-file-code"></i> Input JSON</label>
                <div class="pane-actions">
                    <input type="file" id="upload-json" accept=".json,.txt" style="display:none"
                        onchange="loadFile(this, 'json-input')">
                    <button class="icon-btn" onclick="document.getElementById('upload-json').click()"
                        title="Upload File">
                        <i class="fas fa-upload"></i>
                    </button>
                    <button class="icon-btn" onclick="copyToClipboard('json-input')" title="Copy to Clipboard">
                        <i class="fas fa-copy"></i>
                    </button>
                </div>
            </div>
            <textarea id="json-input" name="input" spellcheck="false" placeholder='{"key": "value"}'
                oninput="validateJSON()"></textarea>
        </div>

        <div class="editor-pane">
            <div class="pane-header">
                <label><i class="fas fa-terminal"></i> Result</label>
                <div class="pane-actions">
                    <button class="icon-btn" onclick="downloadResult()" title="Save Result">
                        <i class="fas fa-download"></i>
                    </button>
                    <button class="icon-btn" onclick="copyToClipboard('result-output')" title="Copy to Clipboard">
                        <i class="fas fa-copy"></i>
                    </button>
                    <button class="run-btn" onclick="runProcess()">
                        <i class="fas fa-play"></i> Run
                    </button>
                </div>
            </div>
            <div id="result-output" class="output-area"></div>
        </div>
    </main>

    <div id="doc-modal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="toggleDoc()">&times;</span>
            <h2>Reference Guide</h2>
            <div id="doc-content" class="markdown-body">
                Loading documentation...
            </div>
        </div>
    </div>

    <!-- About Footer -->
    <footer class="app-footer">
        <div class="footer-content">
            <span>&copy; <span id="year"></span> Gabor Nemet</span>
            <span class="separator">|</span>
            <span>Version: <span id="app-version">Loading...</span></span>
            <span class="separator">|</span>
            <a href="https://github.com/gnemet/mks_sql_parser" target="_blank" title="View Source on GitHub">
                <i class="fab fa-github"></i> GitHub
            </a>
        </div>
    </footer>

    <script src="wasm_exec.js"></script>
    <script>
        // Use Wasm if not running on localhost:8080 (or if explicitly enabled, but for GitHub Pages we assume Wasm)
        // Or better: try to fetch /process, if fails, use Wasm. 
        // Actually, for GitHub Pages migration, we can just default to Wasm if the file exists or just always try to load it.
        // Let's implement a Wasm loader.

        const go = new Go();
        let wasmReady = false;

        // Try to load Wasm
        // Try to load Wasm
        WebAssembly.instantiateStreaming(fetch("mks.wasm?v=" + new Date().getTime()), go.importObject).then((result) => {
            go.run(result.instance);
            console.log("Wasm loaded");
            wasmReady = true;
            // Provide data from Wasm to frontend
            initializeDataFromWasm();
        }).catch((err) => {
            console.log("Wasm not loaded (maybe running on Go server):", err);
            // Fallback to fetch API if Wasm fails (e.g. running on local server without wasm build)
            initializeDataFromFetch();
        });

        // Configure Marked
        marked.setOptions({
            highlight: function (code, lang) {
                const language = hljs.getLanguage(lang) ? lang : 'plaintext';
                return hljs.highlight(code, { language }).value;
            },
            langPrefix: 'hljs language-'
        });

        function initializeDataFromWasm() {
            // Wasm functions: getPatterns(), getTests() return JSON strings
            if (typeof getPatterns !== 'function') {
                setTimeout(initializeDataFromWasm, 100);
                return;
            }

            try {
                const patterns = JSON.parse(getPatterns());
                const tests = JSON.parse(getTests());
                // Version might be string or need parsing? It's just a string.
                if (typeof getVersion === 'function') {
                    document.getElementById('app-version').textContent = getVersion();
                }
                setupUI(tests, patterns);
            } catch (e) {
                console.error("Error loading data from Wasm:", e);
            }
        }

        function initializeDataFromFetch() {
            Promise.all([
                fetch('/tests').then(r => r.json()),
                fetch('/patterns').then(r => r.json()),
                // Server might not expose version? Let's just hardcode fallback or ignore.
            ]).then(([tests, patterns]) => {
                document.getElementById('app-version').textContent = "1.0.0 (Server)";
                setupUI(tests, patterns);
            }).catch(e => console.error("Fetch failed:", e));
        }

        // Set Year
        document.getElementById('year').textContent = new Date().getFullYear();

        function setupUI(tests, patterns) {
            const select = document.getElementById('test-chooser');
            window.tests = tests; // Store globally
            window.patterns = patterns; // Store globally

            // Create Pattern Lookup Map
            const patternMap = {};
            patterns.forEach(p => {
                patternMap[p.id] = p.description;
            });

            // Sort tests by ID ascending
            tests.sort((a, b) => a.id - b.id);

            // Clear options first
            select.innerHTML = '<option value="">Select a Test Case...</option>';

            tests.forEach((test, index) => {
                const opt = document.createElement('option');
                opt.value = index;

                let desc = "Unknown Pattern";
                if (test.description && test.description.length > 0) {
                    desc = test.description;
                } else if (patternMap[test.id]) {
                    desc = patternMap[test.id];
                }

                if (desc.length > 120) desc = desc.substring(0, 117) + "...";

                opt.textContent = `${test.id} - ${desc}`;
                select.appendChild(opt);
            });
        }

        // Load Doc
        // On GitHub Pages, we are likely at /mks_sql_parser/
        // file is at /mks_sql_parser/doc/reference_guide.md if copied?
        // Wait, the deploy action only copies 'mks_so/cmd/server/static'.
        // Does 'static' contain 'doc'? No.
        // We need to copy 'doc' folder to 'static' in the build script!

        const docUrl = wasmReady || window.location.hostname.includes("github.io")
            ? "reference_guide.md" // We will put it in root of static
            : "/doc";

        // We'll try /doc first, if 404, try doc/reference_guide.md? 
        // Actually, let's just try fetching one then the other or depend on mode.
        // Simple heuristic:
        fetch(docUrl).then(r => {
            if (!r.ok) return fetch("doc/reference_guide.md");
            return r;
        })
            .then(r => r.text())
            .then(text => {
                const html = marked.parse(text);
                const docContent = document.getElementById('doc-content');
                docContent.innerHTML = html;
                docContent.style.whiteSpace = 'normal';
                docContent.style.fontFamily = 'inherit';
            });


        // Initial Theme Check
        updateHighlightTheme();

        // document.addEventListener('DOMContentLoaded', () => { ... }); // Removed, we call init above

        function getTestDescription(test) {
            return `Test Case ${test.id}`;
        }

        function loadTest(index) {
            if (index === "" || index === null) return;
            const test = window.tests[index];
            if (test) {
                document.getElementById('sql-text').value = test.text;
                document.getElementById('json-input').value = JSON.stringify(test.input, null, 2);
                document.getElementById('result-output').textContent = "";
            }
        }

        async function runProcess() {
            const sql = document.getElementById('sql-text').value;
            const input = document.getElementById('json-input').value;
            const outputDiv = document.getElementById('result-output');

            outputDiv.textContent = "Processing...";
            outputDiv.className = "output-area";

            if (wasmReady && typeof processSql === 'function') {
                try {
                    // Wasm execution
                    // processSql returns string result directly
                    const result = processSql(sql, input);
                    outputDiv.textContent = result;
                } catch (e) {
                    outputDiv.textContent = "Wasm Error: " + e;
                    outputDiv.classList.add("error-text");
                }
            } else {
                // Server fallback
                try {
                    const response = await fetch('/process', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ sql, input })
                    });

                    const data = await response.json();
                    if (data.error) {
                        outputDiv.textContent = "Error: " + data.error;
                        outputDiv.classList.add("error-text");
                    } else {
                        outputDiv.textContent = data.result;
                    }
                } catch (e) {
                    outputDiv.textContent = "Network Error: " + e.message;
                    outputDiv.classList.add("error-text");
                }
            }
        }

        // Initial Theme Check
        // Check system preference
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.body.classList.replace('light-mode', 'dark-mode');
            document.querySelector('#theme-toggle i').classList.replace('fa-moon', 'fa-sun');
        }
        updateHighlightTheme();

        // Listen for system changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            const body = document.body;
            const icon = document.querySelector('#theme-toggle i');
            // Only update if user hasn't toggled manually? 
            // For simplicity, let system override or just sync.
            // Let's just sync to system change.
            if (event.matches) {
                if (body.classList.contains('light-mode')) {
                    body.classList.replace('light-mode', 'dark-mode');
                    icon.classList.replace('fa-moon', 'fa-sun');
                }
            } else {
                if (body.classList.contains('dark-mode')) {
                    body.classList.replace('dark-mode', 'light-mode');
                    icon.classList.replace('fa-sun', 'fa-moon');
                }
            }
            updateHighlightTheme();
        });

        function toggleTheme() {
            const body = document.body;
            const icon = document.querySelector('#theme-toggle i');
            if (body.classList.contains('light-mode')) {
                body.classList.replace('light-mode', 'dark-mode');
                icon.classList.replace('fa-moon', 'fa-sun');
            } else {
                body.classList.replace('dark-mode', 'light-mode');
                icon.classList.replace('fa-sun', 'fa-moon');
            }
            updateHighlightTheme();
        }

        function updateHighlightTheme() {
            const isDark = document.body.classList.contains('dark-mode');
            const themeLink = document.getElementById('hljs-theme');
            if (isDark) {
                themeLink.href = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css";
            } else {
                themeLink.href = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css";
            }
        }

        function toggleDoc() {
            const modal = document.getElementById('doc-modal');
            modal.style.display = modal.style.display === 'block' ? 'none' : 'block';
        }

        window.onclick = function (event) {
            const modal = document.getElementById('doc-modal');
            if (event.target == modal) {
                modal.style.display = "none";
            }
        }

        /* --- New UX Features --- */

        // 1. File Upload & Drag-n-Drop
        function setupDragDrop(elementId) {
            const dropZone = document.getElementById(elementId);
            if (!dropZone) return;

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, unhighlight, false);
            });

            function highlight(e) {
                dropZone.classList.add('drag-over');
            }

            function unhighlight(e) {
                dropZone.classList.remove('drag-over');
            }

            dropZone.addEventListener('drop', handleDrop, false);

            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                if (files.length > 0) {
                    processFile(files[0], elementId);
                }
            }
        }

        // Initialize Drag & Drop
        setupDragDrop('sql-text');
        setupDragDrop('json-input');

        function loadFile(input, targetId) {
            if (input.files && input.files[0]) {
                processFile(input.files[0], targetId);
                // Reset input so same file can be selected again if needed
                input.value = '';
            }
        }

        function processFile(file, targetId) {
            const reader = new FileReader();
            reader.onload = function (e) {
                const text = e.target.result;
                const target = document.getElementById(targetId);
                target.value = text;

                // If JSON input, trigger validation
                if (targetId === 'json-input') {
                    validateJSON();
                }
            };
            reader.readAsText(file);
        }

        // 2. JSON Validation
        function validateJSON() {
            const input = document.getElementById('json-input');
            const val = input.value.trim();
            if (!val) {
                input.classList.remove('invalid-json');
                return;
            }
            try {
                JSON.parse(val);
                input.classList.remove('invalid-json');
            } catch (e) {
                input.classList.add('invalid-json');
            }
        }

        // 3. Copy to Clipboard
        function copyToClipboard(elementId) {
            let text = "";
            const el = document.getElementById(elementId);

            if (el.tagName === 'TEXTAREA' || el.tagName === 'INPUT') {
                text = el.value;
            } else {
                text = el.innerText; // For div/output
            }

            navigator.clipboard.writeText(text).then(() => {
                // Determine button to give feedback
                // Find button related to this action? 
                // We typically call this from an onclick, but passed ID. 
                // It's hard to find the *exact* button instance easily without passing 'this'. 
                // For now, simpler implementation: just log or simple visual cue if possible.
                // Or we can find button via selector near the element header?
                // Let's keep it simple: maybe show a global Toast? Or just assume it works.
                console.log("Copied to clipboard");
            }).catch(err => {
                console.error('Failed to copy: ', err);
            });
        }

        // 4. Download Result
        function downloadResult() {
            const content = document.getElementById('result-output').innerText;
            if (!content) return;

            const blob = new Blob([content], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = 'result.txt'; // or .sql
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
        }
    </script>
</body>

</html>